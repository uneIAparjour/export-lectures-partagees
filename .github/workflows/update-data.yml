name: Mise √† jour des lectures partag√©es

on:
  # Ex√©cution automatique chaque nuit √† 3h du matin (heure de Paris)
  schedule:
    - cron: '0 2 * * *'
  
  # Ex√©cution manuelle possible depuis l'interface GitHub
  workflow_dispatch:

jobs:
  update-data:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout du repository
        uses: actions/checkout@v4
      
      - name: Installation de Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: R√©cup√©ration et parsing de la page WordPress
        run: |
          cat << 'SCRIPT' > update.js
          const https = require('https');
          const fs = require('fs');

          const PAGE_URL = 'https://www.uneiaparjour.fr/lectures-partagees/';

          const categoriesConfig = {
            etudes: { l: "√âtudes et recherche", c: "#3B82F6" },
            ethique: { l: "√âthique et soci√©t√©", c: "#8B5CF6" },
            travail: { l: "IA et travail", c: "#F59E0B" },
            securite: { l: "S√©curit√© et d√©sinformation", c: "#EF4444" },
            creation: { l: "Cr√©ation, art et m√©dias", c: "#EC4899" },
            technique: { l: "Technique et infrastructure", c: "#10B981" },
            philosophie: { l: "Philosophie et r√©flexions", c: "#6366F1" },
            education: { l: "√âducation", c: "#14B8A6" },
            droit: { l: "Droit", c: "#F97316" },
            geopolitique: { l: "G√©opolitique et international", c: "#06B6D4" }
          };

          function fetchPage(url, timeout = 30000) {
            return new Promise((resolve, reject) => {
              const req = https.get(url, { timeout }, (res) => {
                // Gestion des redirections
                if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
                  return fetchPage(res.headers.location, timeout).then(resolve).catch(reject);
                }
                
                // V√©rifier le code HTTP
                if (res.statusCode !== 200) {
                  return reject(new Error(`HTTP ${res.statusCode} pour ${url}`));
                }
                
                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => resolve(data));
                res.on('error', reject);
              });
              req.on('error', reject);
              req.on('timeout', () => {
                req.destroy();
                reject(new Error(`Timeout apr√®s ${timeout/1000}s pour ${url}`));
              });
            });
          }

          async function fetchWithRetry(url, maxRetries = 3) {
            for (let tentative = 1; tentative <= maxRetries; tentative++) {
              try {
                console.log(`üîÑ Tentative ${tentative}/${maxRetries}...`);
                return await fetchPage(url);
              } catch (err) {
                console.error(`‚ö†Ô∏è Tentative ${tentative} √©chou√©e : ${err.message}`);
                if (tentative === maxRetries) throw err;
                const delai = tentative * 5000; // 5s, 10s, 15s
                console.log(`   Attente ${delai/1000}s avant r√©essai...`);
                await new Promise(r => setTimeout(r, delai));
              }
            }
          }

          function parseHTML(html) {
            const resources = [];
            let currentCategory = null;
            let resourceId = 0;

            // Regex pour trouver les cat√©gories (h2 avec id)
            const categoryRegex = /<h2[^>]*id="(\w+)"[^>]*>/gi;
            const categories = [...html.matchAll(categoryRegex)].map(m => ({
              id: m[1],
              index: m.index
            })).filter(c => categoriesConfig[c.id]);

            // Pour chaque cat√©gorie, extraire les ressources
            categories.forEach((cat, idx) => {
              const startIndex = cat.index;
              const endIndex = idx < categories.length - 1 ? categories[idx + 1].index : html.length;
              const section = html.substring(startIndex, endIndex);
              
              currentCategory = cat.id;

              // Pattern pour une ressource compl√®te
              const resourcePattern = /<p[^>]*>\s*<strong>([^<]+)<\/strong>\s*<\/p>\s*<p[^>]*>([^<]*(?:<[^p][^>]*>[^<]*<\/[^p][^>]*>)*[^<]*)<\/p>\s*<p[^>]*>\s*<em>([^<]*lettre #(\d+)[^<]*du (\d{2})\/(\d{2})\/(\d{4})[^<]*)<\/em>(?:<br[^>]*\/?>)?\s*(?:Lien direct\s*:\s*)?<a[^>]*href="([^"]*)"[^>]*>([^<]*)<\/a>/gi;

              let match;
              while ((match = resourcePattern.exec(section)) !== null) {
                resourceId++;
                const title = match[1].trim();
                let description = match[2].replace(/<[^>]*>/g, '').trim();
                if (description.length > 150) {
                  description = description.substring(0, 147) + '...';
                }
                const letter = parseInt(match[4]);
                const day = match[5];
                const month = match[6];
                const year = match[7];
                const url = match[8];
                const source = match[9].trim();

                resources.push({
                  id: resourceId,
                  t: title,
                  d: description,
                  u: url,
                  dt: `${year}-${month}-${day}`,
                  n: letter,
                  cat: currentCategory,
                  s: source
                });
              }
            });

            return resources;
          }

          function generateJS(resources) {
            const grouped = {};
            resources.forEach(r => {
              if (!grouped[r.cat]) grouped[r.cat] = [];
              grouped[r.cat].push(r);
            });

            let code = '';
            Object.entries(grouped).forEach(([cat, items]) => {
              code += `// ${categoriesConfig[cat]?.l?.toUpperCase() || cat.toUpperCase()}\n`;
              items.forEach(r => {
                const title = r.t.replace(/"/g, '\\"').replace(/\n/g, ' ');
                const desc = r.d.replace(/"/g, '\\"').replace(/\n/g, ' ');
                const source = r.s.replace(/"/g, '\\"');
                code += `{id:${r.id},title:"${title}",desc:"${desc}",url:"${r.u}",date:"${r.dt}",letter:${r.n},cat:"${r.cat}",source:"${source}"},\n`;
              });
            });
            
            return code;
          }

          async function main() {
            try {
              console.log('R√©cup√©ration de la page WordPress...');
              const html = await fetchWithRetry(PAGE_URL);
              
              console.log('Parsing du contenu...');
              const resourcesBrutes = parseHTML(html);
              
              // === VALIDATION INDIVIDUELLE (Faille 5) ===
              const invalides = [];
              const resourcesWP = resourcesBrutes.filter(r => {
                const erreurs = [];
                if (!r.t || r.t.trim().length === 0) erreurs.push('titre vide');
                if (!r.u || !r.u.startsWith('http')) erreurs.push('URL invalide');
                if (!r.dt || !/^\d{4}-\d{2}-\d{2}$/.test(r.dt)) erreurs.push(`date invalide: ${r.dt}`);
                if (!categoriesConfig[r.cat]) erreurs.push(`cat√©gorie inconnue: ${r.cat}`);
                
                if (erreurs.length > 0) {
                  invalides.push({ id: r.id, titre: r.t || '(sans titre)', url: r.u || '', erreurs });
                  return false;
                }
                return true;
              });
              
              if (invalides.length > 0) {
                console.warn(`‚ö†Ô∏è ${invalides.length} ressource(s) invalide(s) ignor√©e(s) :`);
                invalides.forEach(r => {
                  console.warn(`   #${r.id} "${r.titre}" ‚Üí ${r.erreurs.join(', ')}`);
                });
              }
              
              // === GARDE-FOU : Seuil minimum sur le parsing WordPress ===
              const SEUIL_MINIMUM = 50;
              if (resourcesWP.length === 0) {
                console.error('‚ùå ERREUR : Aucune ressource trouv√©e sur WordPress. Parsing probablement cass√©.');
                process.exit(1);
              }
              if (resourcesWP.length < SEUIL_MINIMUM) {
                console.error(`‚ùå ERREUR : Seulement ${resourcesWP.length} ressources pars√©es depuis WordPress (minimum attendu : ${SEUIL_MINIMUM}).`);
                console.error('Le parsing a probablement un probl√®me. Fichier conserv√© tel quel.');
                process.exit(1);
              }
              
              console.log(`‚úÖ ${resourcesWP.length} ressources valides pars√©es depuis WordPress`);
              
              // === Lire le fichier index.html actuel ===
              let indexHTML = fs.readFileSync('index.html', 'utf8');
              
              // === EXTRAIRE LES RESSOURCES EXISTANTES ===
              // On extrait les URLs d√©j√† pr√©sentes dans le tableau R pour d√©dupliquer
              const urlsExistantes = new Set();
              const regexExistantes = /\{id:\d+,[^}]*url:"([^"]*)"[^}]*\}/g;
              let matchExist;
              while ((matchExist = regexExistantes.exec(indexHTML)) !== null) {
                urlsExistantes.add(matchExist[1]);
              }
              const ancienNombre = urlsExistantes.size;
              console.log(`üì¶ ${ancienNombre} ressources d√©j√† pr√©sentes dans index.html`);
              
              // === MODE AJOUT : identifier les nouvelles ressources ===
              const nouvelles = resourcesWP.filter(r => !urlsExistantes.has(r.u));
              
              if (nouvelles.length === 0 && invalides.length === 0) {
                console.log('‚úÖ Aucune nouvelle ressource √† ajouter. Fichier inchang√©.');
                fs.writeFileSync('stats.txt', `${ancienNombre}`);
                process.exit(0);
              }
              
              if (nouvelles.length > 0) {
                console.log(`üÜï ${nouvelles.length} nouvelle(s) ressource(s) √† ajouter :`);
                nouvelles.forEach(r => {
                  console.log(`   + "${r.t}" (${categoriesConfig[r.cat]?.l}, lettre #${r.n})`);
                });
              }
              
              // === RENUM√âROTER les nouvelles ressources ===
              // Le prochain ID = max ID existant + 1
              const regexMaxId = /\{id:(\d+),/g;
              let maxId = 0;
              let matchId;
              while ((matchId = regexMaxId.exec(indexHTML)) !== null) {
                maxId = Math.max(maxId, parseInt(matchId[1]));
              }
              nouvelles.forEach((r, i) => {
                r.id = maxId + 1 + i;
              });
              
              // === G√âN√âRER le JS uniquement pour les nouvelles ressources ===
              const newJS = generateJS(nouvelles);
              
              // === INS√âRER avant la fermeture du tableau ]; ===
              const startMarker = 'const RESOURCES=[';
              const startIndex = indexHTML.indexOf(startMarker);
              if (startIndex === -1) {
                console.error('Marqueur de d√©but "const RESOURCES=[" non trouv√© dans index.html');
                process.exit(1);
              }
              
              // Trouver la fin du tableau (le ]; correspondant)
              let depth = 0;
              let closingBracketIndex = -1;
              for (let i = startIndex + startMarker.length; i < indexHTML.length; i++) {
                if (indexHTML[i] === '[') depth++;
                if (indexHTML[i] === ']') {
                  if (depth === 0) {
                    closingBracketIndex = i;
                    break;
                  }
                  depth--;
                }
              }
              
              if (closingBracketIndex === -1) {
                console.error('Fin du tableau R non trouv√©e dans index.html');
                process.exit(1);
              }
              
              // Ins√©rer les nouvelles ressources juste avant le ]
              const newContent = indexHTML.substring(0, closingBracketIndex) +
                                 newJS +
                                 indexHTML.substring(closingBracketIndex);
              
              // Mettre √† jour la date dans le header
              const today = new Date().toLocaleDateString('fr-FR');
              const updatedContent = newContent.replace(
                /Derni√®re mise √† jour : [^<]*/,
                `Derni√®re mise √† jour : ${today}`
              );
              
              // √âcrire le fichier
              fs.writeFileSync('index.html', updatedContent);
              
              // === RAPPORT D√âTAILL√â ===
              const totalFinal = ancienNombre + nouvelles.length;
              const parCategorie = {};
              resourcesWP.forEach(r => {
                const label = categoriesConfig[r.cat]?.l || r.cat;
                parCategorie[label] = (parCategorie[label] || 0) + 1;
              });
              
              console.log('\nüìã RAPPORT DE SYNCHRONISATION');
              console.log('‚ïê'.repeat(50));
              console.log(`üìÖ Date : ${today}`);
              console.log(`üì¶ Existantes conserv√©es : ${ancienNombre}`);
              console.log(`üÜï Nouvelles ajout√©es : ${nouvelles.length}`);
              console.log(`üìä Total final : ${totalFinal}`);
              if (invalides.length > 0) {
                console.log(`‚ö†Ô∏è  Invalides exclues : ${invalides.length}`);
              }
              console.log('‚îÄ'.repeat(50));
              console.log('R√©partition WordPress :');
              Object.entries(parCategorie)
                .sort((a, b) => b[1] - a[1])
                .forEach(([cat, n]) => {
                  console.log(`   ${cat} : ${n}`);
                });
              console.log('‚ïê'.repeat(50));
              
              // V√©rifier les cat√©gories vides
              const catsVides = Object.keys(categoriesConfig).filter(k => 
                !resourcesWP.some(r => r.cat === k)
              );
              if (catsVides.length > 0) {
                console.warn(`‚ö†Ô∏è Cat√©gories sans ressources sur WordPress : ${catsVides.join(', ')}`);
              }
              
              // === STATS pour le commit message ===
              const statsMsg = nouvelles.length > 0 
                ? `${totalFinal} (+${nouvelles.length} nouvelle${nouvelles.length > 1 ? 's' : ''})` 
                : `${totalFinal}`;
              // Ajouter les invalides dans stats pour l'alerte
              const invalidesMsg = invalides.length > 0
                ? `\nINVALIDES:${invalides.map(r => `${r.titre}|${r.erreurs.join(',')}`).join(';')}`
                : '';
              fs.writeFileSync('stats.txt', statsMsg + invalidesMsg);
              
            } catch (error) {
              console.error('Erreur:', error.message);
              process.exit(1);
            }
          }

          main();
          SCRIPT
          
          node update.js
      
      - name: V√©rifier les changements
        id: check_changes
        run: |
          if git diff --quiet index.html; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "Aucun changement d√©tect√©"
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "Changements d√©tect√©s"
          fi
      
      - name: Commit et push des changements
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          # Extraire uniquement la premi√®re ligne de stats (sans les invalides)
          STATS=$(head -1 stats.txt 2>/dev/null || echo "?")
          rm -f update.js
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add index.html
          git commit -m "üîÑ Mise √† jour automatique : ${STATS} ressources"
          git push

      # === ALERTE RESSOURCES INVALIDES (Faille 5) ===
      - name: Alerter si des ressources sont invalides
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            let statsContent = '';
            try { statsContent = fs.readFileSync('stats.txt', 'utf8'); } catch(e) { return; }
            
            // V√©rifier s'il y a des invalides dans stats.txt
            if (!statsContent.includes('INVALIDES:')) {
              console.log('‚úÖ Aucune ressource invalide d√©tect√©e');
              // Nettoyer stats.txt
              try { fs.unlinkSync('stats.txt'); } catch(e) {}
              return;
            }
            
            // Parser les invalides
            const invalidesLine = statsContent.split('\n').find(l => l.startsWith('INVALIDES:'));
            const invalidesData = invalidesLine.replace('INVALIDES:', '').split(';').map(entry => {
              const [titre, erreurs] = entry.split('|');
              return { titre, erreurs };
            });
            
            // Construire le corps de l'issue
            const tableRows = invalidesData.map(r => 
              `| ${r.titre} | ${r.erreurs} |`
            ).join('\n');
            
            const title = `üîç ${invalidesData.length} ressource(s) √† corriger sur WordPress`;
            const body = [
              `La synchronisation du **${new Date().toLocaleDateString('fr-FR')}** a d√©tect√© des ressources invalides sur la page WordPress.`,
              ``,
              `Ces ressources ont √©t√© **exclues** de l'export et n√©cessitent une correction sur WordPress.`,
              ``,
              `| Ressource | Probl√®me |`,
              `|-----------|----------|`,
              tableRows,
              ``,
              `### Comment corriger`,
              `1. Aller sur la page [Lectures partag√©es](https://www.uneiaparjour.fr/lectures-partagees/) dans WordPress`,
              `2. Corriger les ressources list√©es ci-dessus`,
              `3. Le prochain workflow int√©grera automatiquement les corrections`,
              ``,
              `[Voir le run](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})`,
              ``,
              `---`,
              `*Issue cr√©√©e automatiquement par GitHub Actions*`
            ].join('\n');
            
            // Chercher une issue ouverte existante pour les invalides
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'donn√©es-invalides'
            });
            
            if (issues.data.length === 0) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title,
                body,
                labels: ['donn√©es-invalides']
              });
              console.log('üì¨ Issue "donn√©es-invalides" cr√©√©e');
            } else {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issues.data[0].number,
                title,
                body
              });
              console.log('üì¨ Issue "donn√©es-invalides" mise √† jour');
            }
            
            // Nettoyer stats.txt
            try { fs.unlinkSync('stats.txt'); } catch(e) {}

      # === NOTIFICATION EN CAS D'√âCHEC ===
      - name: Cr√©er une issue en cas d'√©chec
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const title = `‚ö†Ô∏è √âchec de la synchronisation du ${new Date().toLocaleDateString('fr-FR')}`;
            const body = [
              `Le workflow de mise √† jour automatique a √©chou√©.`,
              ``,
              `**Date** : ${new Date().toISOString()}`,
              `**Run** : ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
              ``,
              `V√©rifiez les logs du workflow pour plus de d√©tails.`,
              ``,
              `---`,
              `*Issue cr√©√©e automatiquement par GitHub Actions*`
            ].join('\n');
            
            // V√©rifier qu'une issue similaire n'existe pas d√©j√† (√©viter le spam)
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'sync-error'
            });
            
            if (issues.data.length === 0) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title,
                body,
                labels: ['sync-error']
              });
              console.log('üì¨ Issue de notification cr√©√©e');
            } else {
              // Ajouter un commentaire √† l'issue existante
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issues.data[0].number,
                body: `üîÅ Nouvel √©chec le ${new Date().toLocaleDateString('fr-FR')}.\n\n[Voir le run](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})`
              });
              console.log('üì¨ Commentaire ajout√© √† l\'issue existante');
            }
