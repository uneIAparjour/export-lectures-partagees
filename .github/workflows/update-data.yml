name: Mise √† jour des lectures partag√©es

on:
  # Ex√©cution automatique chaque nuit √† 3h du matin (heure de Paris)
  schedule:
    - cron: '0 2 * * *'
  
  # Ex√©cution manuelle possible depuis l'interface GitHub
  workflow_dispatch:

jobs:
  update-data:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout du repository
        uses: actions/checkout@v4
      
      - name: Installation de Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
      
      - name: R√©cup√©ration et parsing de la page WordPress
        run: |
          cat << 'SCRIPT' > update.js
          const https = require('https');
          const fs = require('fs');

          const PAGE_URL = 'https://www.uneiaparjour.fr/lectures-partagees/';

          const categoriesConfig = {
            etudes: { l: "√âtudes et recherche", c: "#3B82F6" },
            ethique: { l: "√âthique et soci√©t√©", c: "#8B5CF6" },
            travail: { l: "IA et travail", c: "#F59E0B" },
            securite: { l: "S√©curit√© et d√©sinformation", c: "#EF4444" },
            creation: { l: "Cr√©ation, art et m√©dias", c: "#EC4899" },
            technique: { l: "Technique et infrastructure", c: "#10B981" },
            philosophie: { l: "Philosophie et r√©flexions", c: "#6366F1" },
            education: { l: "√âducation", c: "#14B8A6" },
            droit: { l: "Droit", c: "#F97316" },
            geopolitique: { l: "G√©opolitique et international", c: "#06B6D4" }
          };

          function fetchPage(url, timeout = 30000) {
            return new Promise((resolve, reject) => {
              const req = https.get(url, { timeout }, (res) => {
                // Gestion des redirections
                if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
                  return fetchPage(res.headers.location, timeout).then(resolve).catch(reject);
                }
                
                // V√©rifier le code HTTP
                if (res.statusCode !== 200) {
                  return reject(new Error(`HTTP ${res.statusCode} pour ${url}`));
                }
                
                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => resolve(data));
                res.on('error', reject);
              });
              req.on('error', reject);
              req.on('timeout', () => {
                req.destroy();
                reject(new Error(`Timeout apr√®s ${timeout/1000}s pour ${url}`));
              });
            });
          }

          async function fetchWithRetry(url, maxRetries = 3) {
            for (let tentative = 1; tentative <= maxRetries; tentative++) {
              try {
                console.log(`üîÑ Tentative ${tentative}/${maxRetries}...`);
                return await fetchPage(url);
              } catch (err) {
                console.error(`‚ö†Ô∏è Tentative ${tentative} √©chou√©e : ${err.message}`);
                if (tentative === maxRetries) throw err;
                const delai = tentative * 5000; // 5s, 10s, 15s
                console.log(`   Attente ${delai/1000}s avant r√©essai...`);
                await new Promise(r => setTimeout(r, delai));
              }
            }
          }

          function parseHTML(html) {
            const resources = [];
            let resourceId = 0;

            // √âtape 1 : Trouver les cat√©gories via <h2 id="xxx">
            const categoryRegex = /<h2\s+id="(\w+)"[^>]*>/gi;
            const categories = [...html.matchAll(categoryRegex)]
              .map(m => ({ id: m[1], index: m.index }))
              .filter(c => categoriesConfig[c.id]);

            console.log(`üìÇ ${categories.length} cat√©gories trouv√©es : ${categories.map(c => c.id).join(', ')}`);

            // √âtape 2 : Pour chaque section de cat√©gorie, extraire les ressources
            categories.forEach((cat, idx) => {
              const startIndex = cat.index;
              const endIndex = idx < categories.length - 1 ? categories[idx + 1].index : html.length;
              const section = html.substring(startIndex, endIndex);

              // Pattern adapt√© au HTML WordPress r√©el :
              // <p><strong>TITRE</strong></p>
              // <p>DESCRIPTION</p>
              // <p><em>√Ä retrouver dans la <a href="...">lettre #XX</a> du JJ/MM/AAAA</em><br />
              // Lien direct : <a href="URL">SOURCE</a></p>
              //   OU
              // Lien direct : SOURCE (sans lien)</p>
              const resourcePattern = /<p><strong>([^<]+)<\/strong><\/p>\s*<p>([^<]+(?:<[^/][^>]*>[^<]*<\/[^>]+>)*[^<]*)<\/p>\s*<p><em>[^<]*<a[^>]*>lettre #(\d+)<\/a>\s*du\s*(\d{2})\/(\d{2})\/(\d{4})<\/em>\s*<br\s*\/?>\s*Lien direct\s*:\s*(?:<a[^>]*href="([^"]*)"[^>]*>([^<]*)<\/a>|([^<]+))<\/p>/gi;

              let match;
              let sectionCount = 0;
              while ((match = resourcePattern.exec(section)) !== null) {
                resourceId++;
                sectionCount++;
                const title = match[1].trim();
                let description = match[2].replace(/<[^>]*>/g, '').trim();
                if (description.length > 200) {
                  description = description.substring(0, 197) + '...';
                }
                const letter = parseInt(match[3]);
                const day = match[4];
                const month = match[5];
                const year = match[6];
                // Si lien hypertexte existe (match[7]/[8]), sinon texte brut (match[9])
                const url = match[7] || '';
                const source = (match[8] || match[9] || '').trim();

                resources.push({
                  id: resourceId,
                  t: title,
                  d: description,
                  u: url,
                  dt: `${year}-${month}-${day}`,
                  n: letter,
                  cat: cat.id,
                  s: source
                });
              }
              console.log(`   ${cat.id} : ${sectionCount} ressources`);
            });

            return resources;
          }

          async function main() {
            try {
              console.log('R√©cup√©ration de la page WordPress...');
              const html = await fetchWithRetry(PAGE_URL);
              
              console.log('Parsing du contenu...');
              const resourcesBrutes = parseHTML(html);
              
              // === VALIDATION INDIVIDUELLE (Faille 5) ===
              const invalides = [];
              const resourcesWP = resourcesBrutes.filter(r => {
                const erreurs = [];
                if (!r.t || r.t.trim().length === 0) erreurs.push('titre vide');
                if (!r.u || !r.u.startsWith('http')) erreurs.push('URL invalide');
                if (!r.dt || !/^\d{4}-\d{2}-\d{2}$/.test(r.dt)) erreurs.push(`date invalide: ${r.dt}`);
                if (!categoriesConfig[r.cat]) erreurs.push(`cat√©gorie inconnue: ${r.cat}`);
                
                if (erreurs.length > 0) {
                  invalides.push({ id: r.id, titre: r.t || '(sans titre)', url: r.u || '', erreurs });
                  return false;
                }
                return true;
              });
              
              if (invalides.length > 0) {
                console.warn(`‚ö†Ô∏è ${invalides.length} ressource(s) invalide(s) ignor√©e(s) :`);
                invalides.forEach(r => {
                  console.warn(`   #${r.id} "${r.titre}" ‚Üí ${r.erreurs.join(', ')}`);
                });
              }
              
              // === GARDE-FOU : Seuil minimum sur le parsing WordPress ===
              const SEUIL_MINIMUM = 50;
              if (resourcesWP.length === 0) {
                console.error('‚ùå ERREUR : Aucune ressource trouv√©e sur WordPress. Parsing probablement cass√©.');
                process.exit(1);
              }
              if (resourcesWP.length < SEUIL_MINIMUM) {
                console.error(`‚ùå ERREUR : Seulement ${resourcesWP.length} ressources pars√©es depuis WordPress (minimum attendu : ${SEUIL_MINIMUM}).`);
                console.error('Le parsing a probablement un probl√®me. Fichier conserv√© tel quel.');
                process.exit(1);
              }
              
              console.log(`‚úÖ ${resourcesWP.length} ressources valides pars√©es depuis WordPress`);
              
              // === Lire le fichier data.json actuel ===
              let existingData = [];
              try {
                existingData = JSON.parse(fs.readFileSync('data.json', 'utf8'));
              } catch (e) {
                console.log('‚ö†Ô∏è data.json absent ou invalide, cr√©ation depuis z√©ro');
              }
              
              // === EXTRAIRE LES URLS EXISTANTES pour d√©dupliquer ===
              const urlsExistantes = new Set(existingData.map(r => r.url));
              const ancienNombre = existingData.length;
              console.log(`üì¶ ${ancienNombre} ressources d√©j√† pr√©sentes dans data.json`);
              
              // === MODE AJOUT : identifier les nouvelles ressources ===
              const nouvelles = resourcesWP.filter(r => !urlsExistantes.has(r.u));
              
              if (nouvelles.length === 0 && invalides.length === 0) {
                console.log('‚úÖ Aucune nouvelle ressource √† ajouter. Fichier inchang√©.');
                fs.writeFileSync('stats.txt', `${ancienNombre}`);
                process.exit(0);
              }
              
              if (nouvelles.length > 0) {
                console.log(`üÜï ${nouvelles.length} nouvelle(s) ressource(s) √† ajouter :`);
                nouvelles.forEach(r => {
                  console.log(`   + "${r.t}" (${categoriesConfig[r.cat]?.l}, lettre #${r.n})`);
                });
              }
              
              // === RENUM√âROTER les nouvelles ressources ===
              const maxId = existingData.reduce((max, r) => Math.max(max, r.id), 0);
              const nouvellesFormatees = nouvelles.map((r, i) => ({
                id: maxId + 1 + i,
                title: r.t,
                desc: r.d,
                url: r.u,
                date: r.dt,
                letter: r.n,
                cat: r.cat,
                source: r.s
              }));
              
              // === FUSIONNER et √©crire data.json ===
              const finalData = [...existingData, ...nouvellesFormatees];
              fs.writeFileSync('data.json', JSON.stringify(finalData, null, 2), 'utf8');
              
              const today = new Date().toLocaleDateString('fr-FR');
              
              // === RAPPORT D√âTAILL√â ===
              const totalFinal = finalData.length;
              const parCategorie = {};
              finalData.forEach(r => {
                const label = categoriesConfig[r.cat]?.l || r.cat;
                parCategorie[label] = (parCategorie[label] || 0) + 1;
              });
              
              console.log('\nüìã RAPPORT DE SYNCHRONISATION');
              console.log('‚ïê'.repeat(50));
              console.log(`üìÖ Date : ${today}`);
              console.log(`üì¶ Existantes conserv√©es : ${ancienNombre}`);
              console.log(`üÜï Nouvelles ajout√©es : ${nouvelles.length}`);
              console.log(`üìä Total final : ${totalFinal}`);
              if (invalides.length > 0) {
                console.log(`‚ö†Ô∏è  Invalides exclues : ${invalides.length}`);
              }
              console.log('‚îÄ'.repeat(50));
              console.log('R√©partition data.json :');
              Object.entries(parCategorie)
                .sort((a, b) => b[1] - a[1])
                .forEach(([cat, n]) => {
                  console.log(`   ${cat} : ${n}`);
                });
              console.log('‚ïê'.repeat(50));
              
              // V√©rifier les cat√©gories vides
              const catsVides = Object.keys(categoriesConfig).filter(k => 
                !finalData.some(r => r.cat === k)
              );
              if (catsVides.length > 0) {
                console.warn(`‚ö†Ô∏è Cat√©gories sans ressources : ${catsVides.join(', ')}`);
              }
              
              // === STATS pour le commit message ===
              const statsMsg = nouvelles.length > 0 
                ? `${totalFinal} (+${nouvelles.length} nouvelle${nouvelles.length > 1 ? 's' : ''})` 
                : `${totalFinal}`;
              const invalidesMsg = invalides.length > 0
                ? `\nINVALIDES:${invalides.map(r => `${r.titre}|${r.erreurs.join(',')}`).join(';')}`
                : '';
              fs.writeFileSync('stats.txt', statsMsg + invalidesMsg);
              
            } catch (error) {
              console.error('Erreur:', error.message);
              process.exit(1);
            }
          }

          main();
          SCRIPT
          
          node update.js
      
      - name: V√©rifier les changements
        id: check_changes
        run: |
          if git diff --quiet data.json 2>/dev/null; then
            echo "has_changes=false" >> $GITHUB_OUTPUT
            echo "Aucun changement d√©tect√©"
          else
            echo "has_changes=true" >> $GITHUB_OUTPUT
            echo "Changements d√©tect√©s"
          fi
      
      - name: Commit et push des changements
        if: steps.check_changes.outputs.has_changes == 'true'
        run: |
          # Extraire uniquement la premi√®re ligne de stats (sans les invalides)
          STATS=$(head -1 stats.txt 2>/dev/null || echo "?")
          rm -f update.js
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add data.json
          git commit -m "üîÑ Mise √† jour automatique : ${STATS} ressources"
          git push

      # === ALERTE RESSOURCES INVALIDES (Faille 5) ===
      - name: Alerter si des ressources sont invalides
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            let statsContent = '';
            try { statsContent = fs.readFileSync('stats.txt', 'utf8'); } catch(e) { return; }
            
            // V√©rifier s'il y a des invalides dans stats.txt
            if (!statsContent.includes('INVALIDES:')) {
              console.log('‚úÖ Aucune ressource invalide d√©tect√©e');
              // Nettoyer stats.txt
              try { fs.unlinkSync('stats.txt'); } catch(e) {}
              return;
            }
            
            // Parser les invalides
            const invalidesLine = statsContent.split('\n').find(l => l.startsWith('INVALIDES:'));
            const invalidesData = invalidesLine.replace('INVALIDES:', '').split(';').map(entry => {
              const [titre, erreurs] = entry.split('|');
              return { titre, erreurs };
            });
            
            // Construire le corps de l'issue
            const tableRows = invalidesData.map(r => 
              `| ${r.titre} | ${r.erreurs} |`
            ).join('\n');
            
            const title = `üîç ${invalidesData.length} ressource(s) √† corriger sur WordPress`;
            const body = [
              `La synchronisation du **${new Date().toLocaleDateString('fr-FR')}** a d√©tect√© des ressources invalides sur la page WordPress.`,
              ``,
              `Ces ressources ont √©t√© **exclues** de l'export et n√©cessitent une correction sur WordPress.`,
              ``,
              `| Ressource | Probl√®me |`,
              `|-----------|----------|`,
              tableRows,
              ``,
              `### Comment corriger`,
              `1. Aller sur la page [Lectures partag√©es](https://www.uneiaparjour.fr/lectures-partagees/) dans WordPress`,
              `2. Corriger les ressources list√©es ci-dessus`,
              `3. Le prochain workflow int√©grera automatiquement les corrections`,
              ``,
              `[Voir le run](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})`,
              ``,
              `---`,
              `*Issue cr√©√©e automatiquement par GitHub Actions*`
            ].join('\n');
            
            // Chercher une issue ouverte existante pour les invalides
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'donn√©es-invalides'
            });
            
            if (issues.data.length === 0) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title,
                body,
                labels: ['donn√©es-invalides']
              });
              console.log('üì¨ Issue "donn√©es-invalides" cr√©√©e');
            } else {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issues.data[0].number,
                title,
                body
              });
              console.log('üì¨ Issue "donn√©es-invalides" mise √† jour');
            }
            
            // Nettoyer stats.txt
            try { fs.unlinkSync('stats.txt'); } catch(e) {}

      # === NOTIFICATION EN CAS D'√âCHEC ===
      - name: Cr√©er une issue en cas d'√©chec
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const title = `‚ö†Ô∏è √âchec de la synchronisation du ${new Date().toLocaleDateString('fr-FR')}`;
            const body = [
              `Le workflow de mise √† jour automatique a √©chou√©.`,
              ``,
              `**Date** : ${new Date().toISOString()}`,
              `**Run** : ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`,
              ``,
              `V√©rifiez les logs du workflow pour plus de d√©tails.`,
              ``,
              `---`,
              `*Issue cr√©√©e automatiquement par GitHub Actions*`
            ].join('\n');
            
            // V√©rifier qu'une issue similaire n'existe pas d√©j√† (√©viter le spam)
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'sync-error'
            });
            
            if (issues.data.length === 0) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title,
                body,
                labels: ['sync-error']
              });
              console.log('üì¨ Issue de notification cr√©√©e');
            } else {
              // Ajouter un commentaire √† l'issue existante
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: issues.data[0].number,
                body: `üîÅ Nouvel √©chec le ${new Date().toLocaleDateString('fr-FR')}.\n\n[Voir le run](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})`
              });
              console.log('üì¨ Commentaire ajout√© √† l\'issue existante');
            }
